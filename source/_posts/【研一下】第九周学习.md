---
 
title: 第九周学习
date: 2021-4-27
category: 研一下周报
 
---

## BMP

BMP取自位图（Bitmap）的缩写，也称DIB（Device Idependent Bitmap与设备无关位图），是Microsoft开发的一种独立于显示器的数字图像文件格式。

<!-- more -->

BMP的常见颜色深度有：单色（1bit）、16色（4bit）、256色（8bit）、1670 万色（24bit），即每个像素使用多少bit来表示。

![image-20210429214212253](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20210429214212253.png)

位图文件通常是不压缩的，例如，一张512x512的8位灰度位图所占空间约为：512x512x8bit/8/1024=256KB，若为24位彩色图则约为768KB，比相同情况下的压缩格式图像文件（jpeg等）消耗更多的存储空间。也正因为位图数据未经压缩，适合用于图像处理实验。

前面计算的位图文件大小仅仅是数据所占空间，位图文件还包括文件头（Bitmap File Header，14字节）、位图信息数据头（Bitmap Information Header，40字节）、调色板（颜色深度8bit以下不需要）。
$$
BMP\ size = 54 + 4 · 2^n + \frac {width · heigth · n} {8}
$$
以下使用512x512x8位灰度位图`lena512.bmp`实验，使用的二进制数据查看工具为WinHex.exe：

### 文件头

| 偏移                     量 | 大               小 | 用途                                                         |
| :-------------------------: | :-----------------: | :----------------------------------------------------------- |
|            0000h            |        2字节        | 用于标识BMP和DIB文件的魔数，一般为0x42 0x4D，即ASCII的BM。以下为可能的取值：**BM** – Windows 3.1x, 95, NT, ... etc |
|            0002h            |        4字节        | BMP文件的大小（单位为字节）                                  |
|            0006h            |        2字节        | 保留；实际值因创建程序而异                                   |
|            0008h            |        2字节        | 保留；实际值因创建程序而异                                   |
|            000Ah            |        4字节        | 位图数据（像素数组）的地址偏移，也就是起始地址。             |

![image-20210429220625454](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20210429220625454.png)

二进制数据按照little endian方式读取，因此文件大小为：00-04-04-36H，数据开始偏移地址为：00-00-04-36H，相减得到数据大小为：00-04-00-00H=512x512字节。

### 数据头

| 偏移量 | 大小（字节） | 用途                                                         |
| :----: | :----------: | :----------------------------------------------------------- |
|  0Eh   |      4       | 该头结构的大小（40字节）                                     |
|  12h   |      4       | 位图宽度，单位为像素（有符号整数）                           |
|  16h   |      4       | 位图高度，单位为像素（有符号整数）                           |
|  1Ah   |      2       | 色彩平面数；只有1为有效值                                    |
|  1Ch   |      2       | 每个像素所占位数，即图像的[色深](https://zh.wikipedia.org/wiki/色深)。典型值为1、4、8、16、24和32 |
|  1Eh   |      4       | 所使用的压缩方法，可取值见下表。                             |
|  22h   |      4       | 图像大小。指原始位图数据的大小（详见后文），与文件大小不是同一个概念。 |
|  26h   |      4       | 图像的横向分辨率，单位为像素每米（有符号整数）               |
|  2Ah   |      4       | 图像的纵向分辨率，单位为像素每米（有符号整数）               |
|  2Eh   |      4       | 调色板的颜色数，为0时表示颜色数为默认的2*色深*个             |
|  32h   |      4       | 重要颜色数，为0时表示所有颜色都是重要的；通常不使用本项      |

![image-20210429221604330](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20210429221604330.png)

数据头大小：28H=54，宽度：02-00H=512，高度：02-00H=512，位图深度：08H=8位，数据大小：04-00-00-00H，与文件大小-偏移地址计算所得一致。

由数据头1E~21偏移地址，调色板颜色数：01-00H=256种颜色，每种颜色采用4字节存储，因此8位位图的调色板大小为：4·256=1024bit，颜色表示从00-00-00-00至FF-FF-FF-00。

### 像素数据

由之前分析数据，文件头+数据头+调色板一共占用54+1024=1078字节，从偏移量04-36H开始为数据部分，至04-04-35H结束，其中每512个字节代表图像中的一行像素值，共512行。

但是，在分析像素数组时，发现图像第一行位于文件的最后一行，图像的最后一行位于文件的第一行。即图像的原点在左下角而不是左上角。

> 原因是BMP格式最早是由IBM的一帮人开发的。IBM的那帮人比较学院派，认为按通常CG的习惯，坐标原点都应该在图形的左下角，x轴向右，y轴向上。于是就这么定义了BMP的文件格式。只是一个历史的巧合罢了，没有什么深刻的含义。

![image-20210430085654041](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210430085654041.png)

[1] [浅谈图像格式 .bmp](https://zhuanlan.zhihu.com/p/25119530)

[2] BMP维基百科 https://zh.wikipedia.org/wiki/BMP

[3] 标准测试图Lena：https://www.ece.rice.edu/~wakin/images/lena512.bmp

[4] [为什么位图的图像像素数据（大多数）时候是倒过来](https://bbs.csdn.net/topics/30234158)

## LSB

[1] [Chi-KwongChan, L.M.Cheng. Hiding data in images by simple LSB substitution. Pattern Recognition, Volume 37, Issue 3, March 2004, Pages 469-474.](https://www.sciencedirect.com/science/article/pii/S003132030300284X)

### 隐密算法

1. 以8-bit灰度图为例，将原始载体图像表示为C：

$$
C = \{x_{ij}|0 \leqslant i < M_c; \ 0 \leqslant j_i < N_c; x_{ij} \in {0, 1, ..., 255} \}
$$

Mc、Nc分别代表图像的高度和宽度，xij代表像素矩阵中(i, j)位置的像素值。

2. M代表n-bit的秘密信息，表示为：

$$
M = \{ m_i \ | \ 0 \leqslant i < n, \ m_i \in {0, 1}  \}
$$

mi代表n比特流中第i个比特位的值。

3. 假设n-bit的秘密信息M将要嵌入载体图像C的**最右边k位最低比特位**中。首先，将M重新排列组成k-bit的虚拟图像M'：

$$
M' = \{ m' \ | \ 0 \leqslant i < n', m' \in \{ 0, 1, ..., 2^k-1 \} \}
$$

其中n’ < Mc x Nc，原消息M={mi}与待嵌入消息M'={mi'}的映射关系定义为：
$$
m_i' = \sum_{j=0}^{k-1}m_{i \times k+j} \times 2^{k-1-j}
$$
例如：M={0, 1, 1, 1, 1, 0}，当k=1时，M'={0, 1, 1, 1, 1, 0}；当k=2时，M'={01b, 11b}；当k=3时，M‘={011b, 110b}；...

4. 从载体图像C中选取n'个像素{xl1, xl2, ..., xkn'}的预定义序列，则嵌入秘密信息M'的过程是将xli的k-bit的最低有效位替换为mi'。这个选取像素值xli存储秘密信息mi'修改为xli’组成隐密图像的数学表示为：

$$
x_{l_i}' = x_{l_i} - x_{l_i} mod \ 2 ^ k \ + \ m_i'
$$

### 解密算法

给定隐密图像S，嵌入信息可以很容易地提取，而不需要参考原始图像。使用和嵌入过程相同位置的像素序列，取出隐藏了秘密信息的n'个像素集合{xl1', xl2\, ..., xln''}。通过提取每个像素的k-bit最低有效位的值mi'，将M'线性排列即可重构出原始秘密信息M。数学表示这个提取过程为：
$$
m_i' = x_{l_i}' mod \ 2^k
$$

### 代码实现

#### 1. 加密

在8-bit灰度位图lena512.bmp中，在从第一个像素开始嵌入秘密信息`Hello World`：

``` python
import math
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
 
 
def LSB_substitution(cover_img, message, k, offset=0):
    cover = Image.open(cover_img)
    height, width = cover.size
    im = np.array(cover).flatten()     # 像素数组展平
    # ASCII字符转为二进制序列，每个字符用8bit表示
    M = ''.join([ '{:0>8}'.format(format(ord(m), 'b')) for m in message ])
    print('Message:', M)
    n = math.ceil( len(M) / k )  # M重排列分组长度
    M_ = [ M[i*k:(i+1)*k] for i in range(n) ]    # k-bit分组序列M
    # print(M_)
 
    for i in range(n):
        M_[i] = M_[i].ljust(k, '0')       # 最后一个分组可能不满k-bit，向低位补零
        print(f"Offset: {offset+i}, pixel:{format(im[offset+i], 'b')}, embed:{M_[i]}", end=' -> ')
        im[offset+i] = im[offset+i] - im[offset+i] % 2**k + int(M_[i], 2)   # LSB替换公式
        print(format(im[offset+i], 'b'))
    im = im.reshape(height, width)
    stego = Image.fromarray(im)
 
    return stego
 
 
cover_img = 'lena512.bmp'
message = 'Hello World'
stego = LSB_substitution(cover_img, message, 4, 0)
stego.save('stego.bmp')
```

> Message: 0100100001100101011011000110110001101111001000000101011101101111011100100110110001100100
> Offset: 0, pixel:10100010, embed:0100 -> 10100100
> Offset: 1, pixel:10100010, embed:1000 -> 10101000
> Offset: 2, pixel:10100010, embed:0110 -> 10100110
> Offset: 3, pixel:10100001, embed:0101 -> 10100101
> Offset: 4, pixel:10100010, embed:0110 -> 10100110
> Offset: 5, pixel:10011101, embed:1100 -> 10011100
> Offset: 6, pixel:10100011, embed:0110 -> 10100110
> Offset: 7, pixel:10100001, embed:1100 -> 10101100
> Offset: 8, pixel:10100110, embed:0110 -> 10100110
> Offset: 9, pixel:10100010, embed:1111 -> 10101111
> Offset: 10, pixel:10100010, embed:0010 -> 10100010
> Offset: 11, pixel:10100000, embed:0000 -> 10100000
> Offset: 12, pixel:10011011, embed:0101 -> 10010101
> Offset: 13, pixel:10100011, embed:0111 -> 10100111
> Offset: 14, pixel:10100000, embed:0110 -> 10100110
> Offset: 15, pixel:10011011, embed:1111 -> 10011111
> Offset: 16, pixel:10011101, embed:0111 -> 10010111
> Offset: 17, pixel:10011100, embed:0010 -> 10010010
> Offset: 18, pixel:10100001, embed:0110 -> 10100110
> Offset: 19, pixel:10100001, embed:1100 -> 10101100
> Offset: 20, pixel:10011010, embed:0110 -> 10010110
> Offset: 21, pixel:10011100, embed:0100 -> 10010100

以上实验中，`Hello World`共11个字符，每个字符以8bit二进制表示，长度位88bit，以最低有效位数`k=4`嵌入到偏移量开始为0的图像中，改变了`88/4=22`个像素值。将得到的隐密图像`stego.bmp`与原图对比，发生改变的像素值如下：

![image-20210430145841115](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20210430145841115.png)

#### 2. 解密

根据stego隐密图像解密时需要知道信息长度、隐密最低有效位数和偏移量。

``` python
def LSB_extraction(stego_img, message_length, k, offset=0):
    stego = Image.open(stego_img)
    im = np.array(stego).flatten()
    n = math.ceil(message_length*8 / k)
    message = ''
    for i in range(n):
        m = im[offset+i] % 2**k     # LSB提取公式
        message = message + format(m, 'b').rjust(4, '0')
        print(f"Offset: {offset+i}, embedded: {format(m, 'b').rjust(k, '0')}")
    print('M:', message)
    message = ''.join([chr(int(message[i*8:(i+1)*8], 2)) for i in range(message_length)])
    return message
 
message = LSB_extraction('stego.bmp', 11, 4, 0)
print(message)
```

> Offset: 0, embedded: 0100 Offset: 1, embedded: 1000 Offset: 2, embedded: 0110 Offset: 3, embedded: 0101 Offset: 4, embedded: 0110 Offset: 5, embedded: 1100 Offset: 6, embedded: 0110 Offset: 7, embedded: 1100 Offset: 8, embedded: 0110 Offset: 9, embedded: 1111 Offset: 10, embedded: 0010 Offset: 11, embedded: 0000 Offset: 12, embedded: 0101 Offset: 13, embedded: 0111 Offset: 14, embedded: 0110 Offset: 15, embedded: 1111 Offset: 16, embedded: 0111 Offset: 17, embedded: 0010 Offset: 18, embedded: 0110 Offset: 19, embedded: 1100 Offset: 20, embedded: 0110 Offset: 21, embedded: 0100 M: 0100100001100101011011000110110001101111001000000101011101101111011100100110110001100100
> Hello World

### 隐密二维码

二维码的特性是像素只由0和255组成，可以很容易归一化为0和1嵌入到载体图像的末位中，而二维码识别所得链接所指向的信息可以是文本、图像、网页等扩展信息。将以上隐藏字符串的实验代码稍作更改使其用于隐密二维码：

**隐写二维码**：

``` python
cover_img = 'lena512.bmp'
secret_img = 'QRCode.bmp'
 
def LSB_substitution(cover_img, secret_img, k, offset=0):
    # 载体图像
    cover = Image.open(cover_img)
    c_height, c_width = cover.size
    c_im = np.array(cover)     # 像素数组展平
    # 秘密图像
    secret = Image.open(secret_img)
    s_height, s_width = secret.size
    s_im = np.array(secret) // 255      # 二维码只有0,255，直接转为逻辑值0,1
 
    for i in range(s_height):
        for j in range(s_width):
            # LSB隐密公式
            c_im[i][j] = c_im[i][j] - c_im[i][j] % 2**k + s_im[i][j]
    stego = Image.fromarray(c_im)
    return stego
 
stego = LSB_substitution(cover_img, secret_img, k=1)
stego.save('stego.bmp')
```

**提取隐密信息**：

``` python
def LSB_extraction(stego_img, k, offset=0):
    stego = Image.open(stego_img)
    height, width = stego.size
    im = np.array(stego)
    secret_im = np.ones((height, width), dtype=int)
    for i in range(height):
        for j in range(width):
            secret_im[i][j] = (im[i][j] % 2**k) *255   # LSB提取公式
    # plt.imshow(secret_im, cmap='Greys')
    secret = Image.fromarray(secret_im).convert('L')
    return secret
 
stego_img = 'stego.bmp'
secret = LSB_extraction(stego_img, 1)
secret.save('extract.bmp')
```

![image-20210430184950233](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210430184950233.png)

结果依次为：原图、载密图、嵌入二维码、提取结果。

## 图像质量

隐写后的图像相比原图改变的是某些像素点的灰度值，当隐写的最低有效位数k越大时，前后像素值相差越大，从而使图像质量下降。人的视觉能分辨的彩色值约为100w种，RGB彩色共有1670w种，颜色值发生细微变化时肉眼难以察觉；当图像出现人眼可察觉到的模糊时，可以怀疑图像存在较高有效位的隐写。为了避免隐写后图像变化过大，隐写者需要考虑图像质量变化不应太大。以下是两种评判图像质量标准的方法。

### MSE

Mean Square Error，均方误差公式：
$$
MSE = \frac {\sum_{m=1}^M \sum_{n=1}^N [d(m, n)]^2} {M\times N}
$$
其中，d(m, n)是位置(m, n)处隐写前后像素差值。

``` python
from PIL import Image
 
cover = Image.open('lena512.bmp')
stego = Image.open('stego.bmp')
width, height = cover.width, cover.height
MSE = 0
for y in range(height):
    for x in range(width):
         c_pixel = cover.getpixel((x, y))
         s_pixel = stego.getpixel((x, y))
         MSE = MSE + (c_pixel-s_pixel)**2
MSE = MSE / (width*height)
print('MSE:', MSE)
```

对上面实验隐藏二维码的隐秘图像和原载体图像求均方误差，结果为：

> MSE: 0.11022567749023438

考虑**最坏情况**，当载体图像所有的最低k个有效位均被替换为0：

``` python
def LSB_substitution_worst_MSE(cover_img, k):
    # 载体图像
    cover = Image.open(cover_img)
    height, width = cover.size
    im = np.array(cover)     # 像素数组展平
    MSE = 0
    stego = np.ones((height, width), dtype=int)
    for i in range(height):
        for j in range(width):
            # LSB隐密公式
            stego[i][j] = im[i][j] - im[i][j] % 2**k + 0
            MSE = MSE + (im[i][j]-stego[i][j])**2
    Image.fromarray(stego).convert('L').save(f'stego_worst_{k}.bmp')
    MSE = MSE / (width*height)
    return MSE
 
for k in range(1, 6):
    MSE = LSB_substitution_worst_MSE(cover_img, k)
    print(MSE)
```

| k    | 1    | 2    | 3     | 4     | 5      |
| ---- | ---- | ---- | ----- | ----- | ------ |
| MSE  | 0.50 | 3.5  | 17.45 | 77.96 | 324.75 |

![image-20210501101226377](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210501101226377.png)

当k=4时图像质量急剧下降，且均方误差以指数级增长，开始出现肉眼可见的模糊，k=5时与原图差异明显。

### PSNR

峰值信噪比（Peak signal-to noise ratio）用于衡量图像处理前后图像质量变化程度。
$$
PSNR = 10 \times log_{10} \frac {(2^n-1)^2} {MSE}
$$
在颜色深度为8bit的图像中，灰度最大值为255。计算MSE实验中最坏情况下的隐写图像和原图像的PSNR如下：

| k    | 1     | 2     | 3     | 4     | 5      |
| ---- | ----- | ----- | ----- | ----- | ------ |
| MSE  | 0.50  | 3.5   | 17.45 | 77.96 | 324.75 |
| PSNR | 51.13 | 42.68 | 35.71 | 29.21 | 23.01  |

峰值信噪比越低，说明处理后的图像与原图差异越大；信噪比越高，与原图越相近，失真越小。单位是dB。

### 像素调节

像素调节过程（pixel adjustment process，简称PAP）指的是通过调节像素值来提升图像质量的方法。在隐写中，隐写位数较高时往往容易使图像失真，使用PAP降低图像的MSE，使隐写图像更不容易被发现。在上述LSB替换论文中，作者给出了最优像素调整过程（OPAP）的方法，使用少量的计算即可将原MSE降低50%以上，大致思路为：计算原图与载体图像对应像素的差值d(m,n)，如果差值过大，则将其缩小一个bit级，否则不变。

例如：原图像素11001111，隐写像素11000000，隐写最高位k=4，计算差值为1111>2^k=1000，则将隐写像素提升为11000111，所得差值由原来的1111降低至1000，因此可以降低最终计算的MSE值。