---
title: Transport Layer(3)
date: 2021-10-22
category: 计算机网络
tag: TCP
---



> 内容摘自：*Computer Networking: A Top-Down Approach, 6th* *ed.,* J.F. Kurose and K.W. Ross
>
> Chapter 3: **Transport Layer**

### 3.5.5 流控制

我们回顾TCP的接收缓冲区。当TCP连接接收到正确顺序的字节时，它会将数据放在接收缓冲区中。关联的应用程序从这个缓冲区读取数据，但不一定在数据到达时进行。实际上，应用程序可能正在忙于其他任务，甚至在数据到达很久之后才尝试读取数据。如果应用程序读取数据相对较慢，发送者通过太快发送过多数据很容易溢出TCP连接的接收缓冲区。

TCP为其应用程序提供**流控制服务**(Flow-control service)，以消除发送方溢出接收方的缓冲区的可能性。因此，流控制是一种**速度匹配服务**，它将发送者发送的速度与接收应用程序读取的速率相匹配。另一个TCP发送方被限制发送速度的服务是拥塞控制，二者的控制手段是相似的，但显然是出于不同的原因。——流控制是因为应用层读取速度与TCP发送速度不匹配，拥塞控制是因为网络层传输速度与TCP传输速度不匹配。

TCP通过让**发送方**维护一个称为**接收窗口**(recieve window)的变量来提供流控制。简而言之，接收窗口用于让发送者知道接收者有多少可用缓冲空间可用。下图描述了动态接收窗口的变化：

<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211021095746387.png" alt="image-20211021095746387" style="zoom:80%;" />
$$
rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]
$$
具体的，主机B通过将其当前变量值rwnd放在它发送给A的每个段的**接收窗口字段**中，来告诉主机A它在连接缓冲区中有多少空闲空间。主机A保证它不会溢出主机B上的接收缓冲区。因此，主机A确保在整个连接的生命周期中：
$$
LastByteSent – LastByteAcked \leq rwnd
$$
一个极端的问题是，当B主机的接收缓冲区满时，发给A的确认段中`rwnd=0`，A收到后知晓B缓冲区已满，不再发送数据，但当B缓冲区空闲时，无法再通过确认段告知A可以继续发送。为了解决此问题，TCP规范要求主机A在B的接收窗口为零时继续发送带有一个数据字节的段。这些节段将被接收方确认。最终，缓冲区将开始为空，确认将包含一个非零的rwnd值。

UDP不提供流控制服务。对于典型的UDP实现，UDP将段存储在对应socket的有限大小的缓冲区中，socket进程每次读取整个段，如果溢出则直接丢弃段。

### 3.5.6 TCP连接管理

TCP连接给我们唯一的感受可能是网络延时高，还有一些利用TCP连接管理漏洞的SYN洪范攻击。当客户端要连接到服务端时，客户端应用程序首先通知TCP（通过socket）与服务端的TCP连接连接：

1. 客户端TCP发送一个特殊的段，这个段不包含data，但在段头中设置SYN标志位`SYN=1`，这样特殊的段就是**SYN段**。除此之外，客户端TCP需要初始化一个随机的序列号(client_isn)作为序列号：`seq=client_isn`

2. 服务端收到该SYN段后，从段头提取出SYN序号，为该连接分配TCP缓冲区和变量（后面具体详述），然后向客户端TCP发送一个授予连接的段。同样的，这个段也不包含任何data，但是包含三个重要信息：1. SYN=1；2. `ack=client_isn+1`，包含客户端信息防止攻击；3. 初始化随机序列号(server_isn)：`seq=server_isn`

   这个授予连接的段实际上是在说，“我收到了您的SYN数据包，以启动与您的初始序列号client_isn的连接。我同意建立连接。我自己的初始序号是server_isn。”授予连接的段被称为**SYNACK段**。

3. 在收到SYNACK段后，客户端同样需要为连接建立缓冲区和变量。然后发送最后一个段，`SYN=0`代表连接已经建立，`ack=server_isn+1`代表已经收到服务端的连接段，`seq=client_isn+1`是连接完成的序列号。三次握手的第三个阶段可以在TCP段中包含有效负载payload，携带客户端到服务端的数据。

   <img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211021111129732.png" alt="image-20211021111129732" style="zoom:67%;" />

参与TCP连接的两个进程中的任何一个都可以结束该连接。当连接结束时，主机中的“资源”（即缓冲区和变量）将被释放。假设客户端先决定结束连接，客户端发出一个特殊的**FIN段**，标志位`FIN=1`，服务端收到并返回确认；同样的，服务端发出FIN段，客户端回复确认；最终，两台主机上的缓冲区和变量都被释放了。

<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211021112104749.png" alt="image-20211021112104749" style="zoom:67%;" />

以下TCP状态转换图展示了客户端和服务端在建立连接、断开连接不同阶段的状态转换过程：

<table><tr><td>
<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211021115959478.png" />
</td><td>
<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211021120019081.png" />
</td></tr></table>

一个常见的场景是，当服务端没有在80端口开放Web服务，但收到客户端的80端口上的TCP连接请求时，服务端响应一个**重置段**，标志位`RST=1`，告诉客户端”我没有这个段对应端口上的socket，请重发“。当主机接收到一个目标端口号与其连接的UDP套接字不匹配的UDP数据包时，主机将发送一个特殊的ICMP数据报(端口不可达错误)。

当使用Nmap工具通过TCP-SYN扫描端口时，有三种可能的返回结果：

1. 收到SYN-ACK段，代表目标主机端口开放，显示open
2. 收到RST段，代表端口关闭，显示closed。但至少说明SYN包被确认，没有被防火墙拦截
3. 未收到任何消息，可能被防火墙拦截，SYN包未到达目标主机

### 3.7 TCP拥塞控制

TCP的另一个关键组成部分是其拥塞控制机制。正如上一节的流控制，TCP必须使用端到端的控制，而不是网络辅助的拥塞控制，因为IP层没有向端系统提供网络拥塞的显示反馈。TCP所采取的方法是**限制每个发送方作为感知到的网络拥塞而将流量发送到其连接中的速率**。如果TCP发送方感知到自身和目标之间的路径上几乎没有拥塞，那么TCP发送方就会增加其发送速率；如果发送方感知到路径上存在拥塞，那么发送方就会降低其发送速率。但这种方法提出了三个问题：首先，TCP发送方如何限制其向其连接发送流量的速率？第二，TCP发送方如何感知到其自身和目的地之间的路径上存在拥塞？第三，发送方应该使用什么算法来改变其发送速率作为感知到的端到端拥塞的函数？

<u>对于第一个问题</u><u>，TCP如何限制发送流量的速率</u>。在流控制中，TCP连接双方维护各自的接收缓冲区、发送缓冲区和几个变量(接收窗口rwnd等)，类似的，TCP拥塞控制跟踪一个附加变量，即**拥塞窗口**(congestion window, cwnd)，具体来说，发送方处未确认的数据量不得超过cwnd和rwnd的最小值：
$$
LastByteSent – LastByteAcked \leq min\{cwnd, rwnd\}
$$
为了专注于拥塞控制（而不是流控制），让我们今后假设TCP接收缓冲区足够大，以至于可以忽略接收窗口约束；上述约束限制了发送方处未确认的数据量，因此间接限制了发送方的发送速率。在每个RTT开始，约束允许TCP发送cwnd字节的数据到连接中，在RTT结束时，发送放收到确认。因此，发送者的发送速率大约是**cwnd/RTT字节/秒**。因此，通过调整cwnd的值，发送方可以调整其发送数据到其连接的速率。

<u>第二个问题是TCP发送方如何感知自身和目标之间网络上存在拥塞</u>。前面我们说到，为保证TCP可靠传输时，如何判断一个TCP段是否超时丢失的问题，以及收到三个重复ack时的快速重传。我们将TCP发送方的“丢失事件”(loss event)定义为发生超时或接收到3个重复确认。当网络中出现过度拥塞时，路径上的路由器缓冲区将发生溢出，导致IP数据报被删除(TCP段也就没了)，丢弃的数据报反过来会导致发送方处的丢失事件——超时或三个重复的ack的接收——发送方认为这是发送方到接收方路径上拥塞的指示。

正如我们将看到的，TCP将把这些确认的到来作为一切顺利的指示——传输到网络中的段正在成功地交付到目的地——并将使用确认来增加其拥塞窗口大小（从而增加其传输速率）。请注意，如果确认的结果以相对较慢的速度（例如，如果端端路径有高延迟或包含低带宽链路），那么拥塞窗口将以相对较慢的速度增加。另一方面，如果确认率很高，那么拥塞窗口将更快。TCP这种使用确认来触发拥塞窗口大小增加，称为自时钟(self-clocking)。

考虑到调整cwnd值来控制发送速率的机制，关键的问题仍然是：<u>TCP发送者应该如何确定它应该发送的速率</u>？如果集体发送过快可能会堵塞网络；但是，如果TCP发送者过于谨慎和发送速度太慢，他们可能会无法充分利用网络中的带宽；也就是说，TCP发送者可以以更高的速率发送，而不干扰网络。那么，TCP发送者如何确定他们的发送速率，这样他们就不会堵塞网络，而是同时利用所有可用的带宽呢？这就需要合理的**<u>拥塞控制算法</u>**(TCP congestion algorithm)来解决。

TCP遵循以下原则来确定发送速率策略：

1. 一个丢失的段意味着拥塞，因此，当一个段丢失时，TCP发送者的速率应该会降低。超时事件或收到给定段的四个确认（一个原始ACK，然后三个重复ACK）被解释为四层ACKed段之后段的隐性“丢失事件”指示，触发丢失段的重传。从通信控制的角度来看，问题是TCP发送者应该如何减少其拥塞窗口的大小，从而减少其发送率，以响应这个推断的损失事件。
2. 确认段表示网络正在将发送方的段传递给接收方，因此，当以前未确认的段的ACK到达时，发送者的速率可以增加。确认的到来被认为是所有状态良好的隐含指示——片段正在成功地从发送方发送到接收方，因此网络不会拥塞。因此，可以增加拥塞窗口的大小。
3. 带宽探测。在给定表示无拥塞的源到目的地路径和损失事件表示拥挤路径的情况下，TCP调整其传输速率的策略是增加其响应到达的ACKs的速率，直到丢失事件发生的时候，此时，传输速率降低。因此，TCP发送方增加了其传输速率，以探测拥塞开始的速率，退出该速率，然后再次开始探测，看看拥塞开始的速率是否发生了变化。注意，网络没有关于拥塞状态的显式信号——ACKs和丢失事件作为隐式信号——并且每个TCP发送方异步地处理来自其他TCP发件人的本地信息。

鉴于以上对TCP拥塞控制的概述，我们现在可以考虑著名的TCP拥塞控制算法的细节。该算法主要有三个组成部分：**1. 慢开始；2. 拥塞避免；3. 快速恢复**。缓慢启动和避免拥塞是TCP的强制性组成部分，不同于它们如何在响应接收到的ack时增加cwnd的大小。我们很快就会看到，缓慢的开始会更迅速地增加cwnd的大小（尽管它的名字！）而不是避免交通拥堵。建议对TCP发件人进行快速恢复，但不必需要快速恢复。

#### 慢启动

当TCP连接开始时，cwnd的值通常被初始化为1MSS，从而初始发送速率大约为MSS/RTT。例如，如果MSS=500字节和RTT=200毫秒，则产生的初始发送速率仅为约20kbps。由于TCP发送者的可用带宽可能比MSS/RTT大得多，TCP发送者希望快速找到可用带宽的量。在第一次收到确认段时增加1MSS，并发出2MSS；下一次**收到确认时，每个确认增加1MSS**，发出4个MSS；这个过程中每一次RTT发送速率增加一倍，因此，TCP初始时发送速率慢，但是接下来就以指数增长。

<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211022170942980.png" alt="image-20211022170942980" style="zoom: 67%;" />

但这种指数增长的发送速率何时结束呢？一旦存在超时或丢失事件（即发生拥塞），TCP发送方就将cwnd值设为1MSS，并重启慢开始的过程。同时，将**慢启动阈值**(slow start threshold, ssthresh)设为cwnd/2，即拥塞发生时拥塞窗口值的一半。在发生拥塞时，如果下降为一半速率并保持加倍发送，是很鲁莽的策略。因此，**当cwnd的值等于ssthresh时，慢启动阶段结束，TCP过渡到拥塞避免模式**。

#### 拥塞避免

在进入避免拥塞的状态时，cwnd的值大约是上次遇到拥塞时值的一半——拥塞可能即将来临！因此，TCP的保守的做法是，采取每个RTT的cwnd值仅增加一个MSS的**线性增加**策略，而不是慢开始时的加倍。那么在什么时机增加1MSS呢？这取决于MSS/cwnd的值，如果当前cwnd越大，则cwnd曲线线性增长率越小。同样的，当再次发生超时事件时，每RTT1MSS线性增长结束并设当前cwnd=1，ssthresh=上一次cwnd/2；但当发生3重重复确认(3-ack)等事件时，表明网络已经非常拥塞了，不应该保持之前的策略，此时拥塞控制进入快速恢复阶段。

#### 快速恢复

在快速恢复中，对于导致TCP进入快速恢复状态的缺失段的每个重复ACK，cwnd值就会增加1个MSS。最终，当ACK到达缺失段时，TCP在收缩cwnd后进入避免拥塞状态。如果发生超时事件，则在执行与慢启动和避免拥塞相同的操作后，快速恢复转换到慢启动状态：cwnd值设置为1MSS，ssthresh值在损失事件发生时设置为cwnd值的一半。Tahoe和Reno是两种不同的恢复策略。

<img src="https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/typora/image-20211022173443596.png" alt="image-20211022173443596" style="zoom:80%;" />

在TCP发展十年后，理论分析表明，TCP的拥塞控制算法是一种分布式异步优化算法，可以使用户和网络性能的几个重要方面同时得到优化。重要的是要认识到TCP拥塞控制多年来不断发展，而且确实在持续发展。