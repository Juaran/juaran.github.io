---
title: DNS在V2Ray中的应用
date: 2022-04-01
category: 计算机网络
tags: [proxy, DNS]
---



DNS及其应用：https://steemit.com/cn/@v2ray/dns

[漫谈各种黑科技式 DNS 技术在代理环境中的应用](https://tachyondevel.medium.com/漫谈各种黑科技式-dns-技术在代理环境中的应用-62c50e58cbd0)

![https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/notion20220412102529.png](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/notion20220412102529.png)

# 使用情境

即使你不使用代理功能，现在 V2Ray 也可以作为一个**智能 DNS**来用了。更多有趣的功能还等着你来发掘。

## 广告屏蔽

V2Ray 的 DNS 服务器自带了 hosts 功能。当然我们的 hosts 比传统的操作系统自带的 hosts 文件强大很多，你只需要一行就可以屏蔽很多广告域名了。示例如下：

```json
"dns": {
    "hosts": {
      "geosite:category-ads": "127.0.0.1"
    }
}
```

这一项的意思是对于所有 'category-ads' 中的域名，把 IP 解析到 '127.0.0.1'，即一个肯定访问不了的 IP。'category-ads' 是 'geosite'中的一个特殊项，它包含了一些常见的广告域名，具体的内容[点这里](https://github.com/v2ray/domain-list-community/blob/master/data/category-ads)。如果你觉得还不够的话，欢迎按照格式提交 PR。

## 域名别名

由于众所周知的原因，'[v2ray.com](http://v2ray.com)' 的 IP 在某些地区被解析到了 Facebook 的数据中心。实际上，'[v2ray.com](http://v2ray.com)' 用的是 CloudFlare 的服务。**CloudFlare 是一个 CDN，它的单个 IP，通常可以承载多个域名的流量**。于是，我们即使不查询 '[v2ray.com](http://v2ray.com)'，而使用另一个域名（比如 '[www.vicemc.net](http://www.vicemc.net)'），同样也可以得到一个可用的 IP。配置样例如下：

```json
"dns": {
    "hosts": {
      "domain:v2ray.com": "www.vicemc.net"
    }
}
```

其中 'dns' 和 'hosts' 和上面一段的配置是一模一样的，实际的配置中，只需要写一遍就可以了。区别是这里把所有 '[v2ray.com](http://v2ray.com)' 的域名（包括子域名）指向了 '[www.vicemc.net](http://www.vicemc.net)'。在实际使用中，V2Ray 会通过 DNS 传出代理，拦截 '[v2ray.com](http://v2ray.com)' 的查询，改写成 '[www.vicemc.net](http://www.vicemc.net)' 再发送出去，完全避免了 DNS 污染。

## DNS查询分流

在使用代理的时候，DNS 查询经常得到不合理的 IP，比如淘宝被解析到了一个国外的 IP，导致访问缓慢。这是因为代理软件修改了来源 IP 地址，DNS 服务器不知道你的实际位置，而是返回了一个离代理服务器较近的 IP 地址。解决这一问题的方法有很多，比如 EDNS Client Subnet。

这里 V2Ray 提供了一个理解起来更方便的方法：DNS 分流。即对于国内的域名，向国内的 DNS 服务器发送查询；其它的域名，向国外的服务器查询。示例如下：

```json
"dns": {
  "servers": [
      "1.1.1.1",
      {
        "address": "114.114.114.114",
        "port": 53,
        "domains": ["geosite:cn"]
      },
			"8.8.8.8",
      "localhost"
  ]
}
```

这段配置的意思是，所有常用的国内域名（'geosite:cn'）都使用 '114.114.114.114' 作为 DNS 服务器；而其它的域名使用 '1.1.1.1'。**'geosite:cn' 尽可能地包含了国内外 IP 地址不同的域名**，这些域名需要查询就近的 DNS 服务器。而对于那些只有单个 IP 的小站点，查哪里是一样的

# DNS使用配置

## 未代理

1. 终端主机发出DNS域名解析请求，IP数据报形式为UDP段文
2. 所请求的本地DNS服务器为终端主机网络设置的DNS服务器，如`223.5.5.5`，备用223.6.6.6；在手机上使用数据流量则请求ISP的DNS服务器。该过程一般为递归查询
3. 本地DNS服务器向其他域名服务器发起迭代查询
4. 查询结果(IP地址)由本地DNS服务器返回给终端主机
5. 终端主机以该IP地址作为`dest ip address` 向目标域名的主机发送HTTP报文，或HTTPS握手连接

## SOCK5代理

开启V2Ray本地代理，入口设置为`socks` 即SOCKS5代理，出口设置为`freedom` 直连：

```json
{
    "inbounds": [{
        "port": 1080, // 监听端口
        "protocol": "socks", // 入口协议为 SOCKS 5
				"settings": {
            "auth": "noauth",
            "udp": true,
            "ip": "127.0.0.1"
        }
    }],
    "outbounds": [{
        "protocol": "freedom", // 出口协议
        "settings": {}
    }]
}
```

此时，由于V2Ray接管了本地终端的所有流量，并以直连的方式向外发出请求。虽然V2Ray也代理了UDP请求，但这无疑是画蛇添足多此一举——只不过换了一个工具来发起UDP请求。

加了这么一层代理，看起来什么都没发生，只是换了角色，其实不然，角色这么一换，可做的事情就相当多了。拿 DNS 来说，原来是浏览器发起的 DNS 请求，我们没办法控制浏览器怎么去发这个 DNS 请求（你不可能去改浏览器的源代码自己编译一个来用吧？），但换成由 V2Ray 来发这个 DNS 请求后，我们就可以做很多事情。

修改配置，将出口流量的域名解析策略`domainStrategy`设置为`UseIP` ：

```json
"outbounds": [{
	    "protocol": "freedom", // 出口协议
	    "settings": {
	        "domainStrategy": "UseIP"
	    }
  }]
```

V2Ray文档中对`freedom`直连出口设置的改项解释为：当目标地址为域名时（通常是DNS查询数据报），直接向此域名发出连接（"`AsIs`"），或使用V2Ray内置的DNS解析为IP后再进行连接（"`UseIP`"、"`UseIPv4`"、"`UseIPv6`”）

也就是说，V2Ray在代理终端UDP查询的基础上，能够更改本地查询的DNS服务器。添加DNS配置：

```json
"dns": {
    "servers": [
        "223.5.5.5",
        "8.8.8.8",
        "localhost"
    ]
}
```

通过Wireshark抓包能够看到DNS查询的服务器为233.5.5.5，而且同时也会向"8.8.8.8", “1.1.1.1”(Windows电脑设置的DNS)发起DNS查询：

![https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/notion20220412102559.png](https://cdn.jsdelivr.net/gh/juaran/juaran.github.io@image/notion20220412102559.png)

因为我们配置了三个DNS服务器，且没有设置任何**路由规则**（后续有重要作用），V2Ray会按照顺序发起DNS查询请求

## 路由选择

DNS查询与路由选择密切相关。**路由选最佳出口**需要DNS查询来完成。当设置了V2Ray的路由规则后，符合匹配规则的inbounds流量将从对应的outbounds发出。我们首先需要设置两个不同的出口：

```json
"outbounds": [{
        "tag": "direct", // 这个出口直连
        "protocol": "freedom", // 出口协议
        "settings": {
            "domainStrategy": "UseIP" // 使用内置DNS解析
        }
    },
    {
        "tag": "myProxy", // 这个出口将到我的远端代理服务器
        "protocol": "vmess",
        "settings": {
            "vnext": [{
                "address": "1.12.246.131",
                "port": 16823,
                "users": [{
                    "id": "0c408899-c843-4f63-af6a-539d17070531",
                    "alertId": 0
                }]
            }]
        }
    }
],
```

一个出口为本地直连，一个出口为远端V2Ray代理服务器。接下来我们设置路由规则：

```json
"routing": {
    "domainStrategy": "IPIfNonMatch", // 域名策略
    "rules": [{
        "type": "field", // 匹配类型
        "ip": ["8.8.8.8"], // 匹配IP列表
        "outboundTag": "myProxy" // 使用代理出口
    }, {
        "type": "field",
        "domain": ["geosite:cn"], // 匹配域名列表
        "outboundTag": "direct" // 使用直连出口
    }]
},
"dns": {
    "servers": [
        "8.8.8.8",
        "localhost"
    ]
}
```

第一条路由规则设置为：当匹配到目标IP为“8.8.8.8”时，使用远端代理服务器进行请求；

第二天路由规则为：当域名匹配国内常见域名时，使用直连出口；同时，在直连出口中我们设置了使用内置DNS进行解析。

但是路由的域名策略是什么呢？

> V2Ray 内建了一个简单的路由功能，可以将入站数据按需求由不同的出站连接发出，以达到按需代理的目的。这一功能的常见用法是分流国内外流量，V2Ray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。****

- `“AsIs”`：只使用域名进行路由选择。默认值。

- ```
  "IPIfNonMatch"
  ```

  : 当域名没有匹配任何规则时，使用内置DNS将域名解析成 IP（A 记录或 AAAA 记录）

  再次

  进行匹配；

  - 当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止；
  - 解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；

- `"IPOnDemand"`: 当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；

我们回看以上两条路由规则：

1. 当访问国内地址时，经过路由规则匹配到了直连出口
2. 当访问google.com时，发现没有这个域名的路由匹配，也就找不到出口
3. 但由于设置了`IPIfNonMatch` ，路由转而告诉V2Ray核心去解析出IP再来进行路由选择
4. 于是V2Ray使用内置的DNS对google.com进行DNS解析，配置中第一个DNS为8.8.8.8
5. 发出的DNS解析是UDP段，目的地址是8.8.8.8，于是匹配到了第一条路由规则
6. 这个DNS查询将发往`myProxy` ，由远端V2ray服务代解析，再把解析结果传回来

以上，远端服务器仅仅充当了代理DNS的功能。如果要代理后续的HTTP请求呢？在本地出口设置`streamSettings` 为TCP传输：

```json
"outbounds": [
    {
        "tag": "myProxy", // 这个出口将到我的远端代理服务器
        "protocol": "vmess",
        "settings": {
            "vnext": [{//...}]
        },
        "streamSettings": { // 流传输设置
            "network": "tcp" // TCP流量
        }
    }
],
```

这意味着本地V2Ray将与远端V2Ray建立起TCP流量隧道的代理连接。

小结：一般来说，流量从 inbound 进入到 V2Ray，再进入到路由匹配过程，找到匹配到的 outbound，然后流量就给到这个 outbound 处理。V2Ray 虽然有多种 inbound，多种 outbound，以及很灵活的路由匹配规则，有时候会让人眼花缭乱，但这条流量流经的路线是默认的，没有特殊配置，流量都会按这个顺序在 V2Ray 内部传递。

## 内置DNS

前文讲到，V2Ray可以设置出口流量的域名策略为`UseIP` 以使用内置DNS进行查询；同时在路由选择时，也会借用内置DNS进行IP解析以更好地匹配出口。对其他模块来说，内置DNS只负责解析传入域名的IP并返回列表。

### hosts

和系统中的/etc/hosts功能一样，V2Ray内置DNS下的hosts处理可以自定义DNS映射：

```json
"dns": {
  "hosts": {
    "www.google.com": "127.0.0.1"
  }
}
```

由此可以衍生出更强大的功能，例如：屏蔽广告域名、DNS污染解除等

### servers

终端可以配置一系列的DNS server提供给V2Ray，内置 DNS 会从上至下按顺序，向 servers 里每个 DNS 服务器发 DNS 依次请求，直到有结果返回，然后再把结果返回给路由模块：

```json
"dns": {
    "servers": [
        "223.5.5.5",
        "8.8.8.8",
        "localhost"
    ]
}
```

> 从内置 DNS 向 servers 列表中的 DNS 服务器发出的 DNS 请求的流量，并不是从本机直接发到对应的服务器（localhost 除外），而是会通过 outbound 发出去，假如是 Freedom outbound，的确还是会从本机直接发到相应 DNS 服务器，但假如是一个 VMess outbound，DNS 请求的流量就会被代理到 VMess 代理服务器上，由代理服务器发到相应的 DNS 服务器。

也即V2Ray产生的DNS查询流量，将从路由选择的出口流出。但是问题来了，我配置了多个DNS服务器，查询时该走哪条道呢？[假如访问的是bilibili.com](http://xn--bilibili-wb4mi67e415aq74byx5c213a.com)，应该查询223.5.5.5，而访问google.com时应该查询8.8.8.8。虽然路由选择可以保证国内站点走freedom，国外站点走porxy，但不管是哪个出口，都是进行DNS查询，只不过是交给我本地来查询还是交给远端来查询。

V2Ray 当然已经考虑到这情况，有了所谓的 `DNS 分流` 功能：

```bash
"servers": [
    "8.8.8.8",
    {
        "address": "114.114.114.114",
        "port": 53,
        // List of domains that use this DNS first.
        "domains": [
            "geosite:cn"
        ]
    },
    "localhost"
]
```

这样配置内置 DNS，虽然 8.8.8.8 在第一，但因为要查询的域名 [www.bilibili.com](http://www.bilibili.com/) 匹配了第二项中的域名规则，内置 DNS 就会优先向第二个 DNS 服务器发出 DNS 请求。

这里有一个很容易忽略掉的过程，就是选择 outbound，我们用 DNS 分流功能选择了 DNS 服务器，还得在路由中配置合适的规则，来选合适的 outbound 向这个 DNS 服务器发出 DNS 请求流量。

```bash
"routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
        {
            "type": "field",
            "ip": [
                "8.8.8.8"
            ],
            "outboundTag": "proxy"
        },
        {
            "type": "field",
            "ip": [
                "223.5.5.5"
            ],
            "outboundTag": "direct"
        }
    ]
}
```

总结一下上面的，要正确配置 V2Ray 内置 DNS：

1. 正确配置 servers 列表及域名分流（用域名信息来选 DNS 服务器）
2. 正确为发出的 DNS 请求配置路由规则（用 DNS 服务器的地址信息以及流量的协议信息：IP，端口，tcp/udp）

## ***\*DNS Outbound\****

> 我们上面的例子中所说的都是路由模块去调用内置 DNS，但路由模块仅仅是用它的结果来做规则匹配，而且是当配置了 `IPIfNonMatch/IPOnDemand` ，而且没有匹配任何域名规则的情况下，才用得到它，当下各种域名列表盛行，它的应用范围实际上是很窄的。

就是说，我们实际上没有必要去通过路由来调用内置DNS得到IP来匹配路由，用域名列表匹配更合适

`DNS outbound`可以说是一个把内置 DNS 的功能真正地开放出来，让各种程序、各种模块可以更加方便地使用得上内置 DNS 的一个功能。最主要的目的还是，有些时候希望把V2Ray单纯当做DNS分流应用来使用。

DNS outbound配置只有三个设置：network，address，port

```json
"outbounds": [
    {
        "tag": "dns-out",
        "protocol": "dns",   // 出站协议为DNS
        "settings": {
            "network": "tcp",
            "address": "1.1.1.1",
            "port": 53
        }
    }
]
```

DNS outbound 最重要的功能是它的默认行为：对进来的 DNS 流量进行**拦截、解析**，以及对 A, AAAA 类型的 DNS 查询做**重新转发**。

```bash
1. 某个应用程序发了一个 DNS 查询
2. 这个 DNS 查询的流量通过某种方式进入了 DNS outbound（这里暂时不讨论究竟是通过什么方式进入 DNS outbound 的）
3. 如果这个流量是个明文 DNS 请求，DNS outbound 肯定看得到里面内容，可以拿出里面的域名
4. DNS outbound 调用内置 DNS 模块，把拿到的域名传进去
5. 内置 DNS 模块根据它的配置去查这个域名的 IP，具体怎么查的，DNS outbound 并不知道，它只管要结果
6. 内置 DNS 返回一些 IP 给 DNS outbound 后，DNS outbound 用这些 IP 生成了一个 DNS 回复
7. DNS outbound 把这个 DNS 回复若无其事地返回给应用程序
8. 应用程序当然不知道这个 DNS 回复具体是怎么来的，它没办法，只能相信中间链路，相信这个回复就是它想要的回复
```

DNS outbound 的这种行为，实质上相当于 DNS 劫持，但说它是 DNS 劫持也不太对，因为是我们配置的，自愿让它 “劫持” 的。

那么，V2Ray能够实现重发DNS数据，重点就在于**如何拦截到**其他应用的DNS流量？

比如运行一个 `nslookup` 命令，默认它也不会用系统设置的代理，它是直接向系统设置的 DNS 服务器发 DNS 请求，怎么把这个请求的流量引导到 V2Ray 的 DNS outbound 呢？

### PC端使用

新建以下配置：

```json
{
    "inbounds": [
        {
            "port": 53,  // 监听本地53端口。需要设置本地DNS为127.0.0.1才会进来
            "tag": "dns-in",
            "protocol": "dokodemo-door",  // dokodemo-door是V2Ray的DNS服务器应用程序
            "settings": {
                "address": "1.1.1.1",
                "port": 53,
                "network": "tcp,udp"
            }
        }
    ],
    "dns": {
        "hosts": {  // 自定义映射
            "domain:www.bilibili.com": "1.2.3.4"
        }
    },
    "outbounds": [
        {
            "protocol": "dns",   // 出站协议为DNS，将调用内置DNS进行查询
            "tag": "dns-out"
        },
        {
            "protocol": "freedom",
            "tag": "direct",
            "settings": {}
        }
    ],
    "routing": {
        "rules": [
            {
                "type": "field",
                "inboundTag": ["dns-in"],  // 路由匹配dns-in的Inbounds流量
                "outboundTag": "dns-out"  // 从dns-out出
            }
        ],
        "strategy": "rules"
    }
}
```

1. 命令行执行 nslookup[www.bilibili.com](http://www.bilibili.com/)
2. 因为系统 DNS 设置为 127.0.0.1
3. DNS 请求发到 dokodemo-door inbound
4. 因为 "dns-in" -> "dns-out" 路由规则，流量传给 DNS outbound
5. DNS outbound 识别到是个 DNS 请求，拿到域名 [www.bilibili.com](http://www.bilibili.com)，调用内置 DNS
6. 这个域名匹配到内置 DNS 的一条 hosts 规则，返回结果 1.2.3.4
7. 于是 nslookup 查询[www.bilibili.com](http://www.bilibili.com/)的结果是 1.2.3.4

让 V2Ray 充当 DNS 服务器，设置系统 DNS 是其中一个把 DNS 流量引导到 DNS outbound 中的方式。但今天我们大部分的上网操作都是在浏览器上进行了，浏览器用了 SOCKS5 代理的话也不需要本地去解析 DNS，所以这个应用场景不常见。

小结：PC端能够设置socks代理精准将DNS流量导向到内置DNS进行解析。

### 移动端

> *DNS outbound 开放出来后，最重要的应用场景，是在移动端和路由器上。*

> 在讨论移动端和路由器之前，先看看桌面系统上怎样可以做真正的全局代理。前面也说了，一般的浏览器代理，只代理浏览器的流量，要把 DNS 流量也代理了，就需要像上面那样更改系统 DNS 为 127.0.0.1，当我们需要真正的全局代理时（VPN 就是真正的全局代理），这种方便显然不合适，也不可能做得到真正全局代理。

请参考以下几种”全局”代理工具：

# 全局代理

## tun2socks

通过 tun2socks，能够把所有本机应用程序发出的流量都交给 V2Ray/SOCKS/Shadowsocks，从而达到全局 TCP/UDP 代理（对，只是 TCP/UDP，ICMP 等等是不支持的，全局性还是不比真正的 VPN）

tun2socks工具：golang实现

https://github.com/eycorsican/go-tun2socks

- Windows：[[教程\] 在 Windows 上使用 tun2socks 进行全局代理](https://tachyondevel.medium.com/教程-在-windows-上使用-tun2socks-进行全局代理-aa51869dd0d)

```bash
{
    "dns": {
        "hosts": {
            "domain:www.bilibili.com": "1.2.3.4"
        }
    },
    "outbounds": [
        {
            "protocol": "dns",
            "tag": "dns-out"
        },
        {
            // VMess outbound
        }
    ],
    "routing": {
        "rules": [
            {
                "type": "field",
                "network": "udp",
                "port": 53,
                "outboundTag": "dns-out"
            }
        ],
        "strategy": "rules"
    }
}
```

配置中没有 inbound，因为我们所用的 tun2socks 软件：[go-tun2socks](https://github.com/eycorsican/go-tun2socks)本身把 tun2socks 内置为 V2Ray 的一个 inbound 了。

## Mellow

> *`go-tun2socks` 是一个命令行工具，要使用的话还要自己创建 TUN 接口，配置路由表等，比较繁琐，这里还有另一个应用叫 [Mellow](https://github.com/eycorsican/Mellow) ，对 `go-tun2socks` 进行了包装，可以自动完成这些繁琐的步骤，实际使用起来的效果就相当于 Proxifier、SSTap、Surge for Mac 等软件，可以把所有流量都代理了：*

https://github.com/mellow-io/mellow

## 移动端环境

要代理所有 app 的流量，tun2socks 是一种必须的手段，它们跟桌面系统上用 tun2socks 很相似，都是要把所有的 TCP/UDP 流量引导进 V2Ray，但也有不一样的地方，*移动端系统一般都提供了特殊的方法，能够让指定的流量不受路由表基于 IP 地址的路由控制*。

在移动端系统方面，iOS 既可以像桌面系统用 tun2socks 那样把所有 TCP/UDP 流量引导到 V2Ray，也可以设置一个 **HTTP 代理**把 HTTP 请求代理到 V2Ray 的 HTTP inbound 里；而 Android，只能以 tun2socks 那样的方式把 TCP/UDP 流量引导进去。

iOS 的 HTTP/S 代理跟 SOCKS5 代理比较相似，应用程序不需要自己解析 DNS，可以把域名带上交给 V2Ray，然后如果请求匹配到代理的路由规则，这个域名就通过代理协议（VMess/Shadowsocks/SOCKS5）交给代理服务器自己去解析，所以本地不需要做任何 DNS 解析。问题是很明显这个只适用于 HTTP/S 请求（而且并不是所有的 HTTP/S 请求，貌似应用程序还必须要用 iOS 系统提供的 HTTP 库来做请求才会被代理到）。

再考虑到 Android 并不能很自然地支持 HTTP/S 或者 SOCKS5 代理，所以想要一个通用的解决方案，还是要从 TCP/UDP 流量入手。kitsunebi软件内置了go-tun2socks和V2Ray核心，能够将所有本地TCP/UDP流量引导到V2Ray代理链上：

https://github.com/eycorsican/kitsunebi-android

```bash
{
    "dns": {
        "hosts": {
            "domain:www.bilibili.com": "1.2.3.4"
        },
        "servers": [
            "114.114.114.114",
            {
                "address": "8.8.8.8",
                "domains": [
                    "google"
                ],
                "port": 53
            }
        ]
    },
    "outbounds": [
        {
            "protocol": "vmess",
            "tag": "proxy"
        },
        {
            "protocol": "freedom",
            "settings": {},
            "tag": "direct"
        },
     {
         "protocol": "dns",
         "tag": "dns-out"
     }
    ],
    "routing": {
        "rules": [
            {
                "inboundTag": ["tun2socks"],
                "network": "udp",
                "port": 53,
                "outboundTag": "dns-out",
                "type": "field"
            },
            {
                "ip": [
                    "8.8.8.8/32"
                ],
                "outboundTag": "proxy",
                "type": "field"
            }
        ],
        "strategy": "rules"
    }
}
```

配置中的 inboundTag tun2socks 是必须的，虽然单凭 53 端口 和 network udp 大致达到识别出 UDP 流量的目的，但因为在 V2Ray 中 UDP 流量并不只从 tun2socks inbound 进来，还会从 内置 DNS 那边过来，如果不加上 inboundTag tun2socks 这个限制，内置 DNS 那边过来的流量就会被转到 DNS outbound，接着有可能又被转给 内置 DNS，造成环路。

# 其他

## Fake DNS

大体上，从流量流向的角度来看，一般 DNS 处理方式也就 3 种：

- 直接从本机发出 DNS 请求到目的 DNS 服务器
- 通过代理把 DNS 请求发送到目的 DNS 服务器
- 本机不向互联网发出 DNS 请求流量（由远端代理服务器来解析或者直接本地伪造 DNS 答复返回）

虽然现在已经可以完全利用 V2Ray 的 DNS 功能模块对 DNS 的 UDP 流量做各种处理，可以对 DNS 请求按域名做分流，但仔细想想，分流时不管是发到 freedom outbound 直连还是发到 VMess outbound 代理，这些 DNS 请求终究是要以实际的流量形式从本地发送到互联网上，是否有方法可以在利用 tun2socks 获取所有 TCP/UDP 流量的同时，又可以像 HTTP/S 和 SOCKS5 代理那样，本地完全不发出 DNS 请求流量，只把域名交给代理服务器，让代理服务器自己去解析呢？

答案是有的，那就是 Fake DNS，Fake DNS 是有一个 [RFC](https://tools.ietf.org/html/rfc3089) 的，某些使用 iOS 的读者可能也并不陌生，Surge 中的 `force-remote-dns` 就是利用了这种技术。

```bash
1. 手机上某个 app 想发出 <https://www.google.com> 请求
2. app 发出 www.google.com 的 DNS 查询
3. DNS 请求的 UDP 流量来到 tun2socks，被 tun2socks 交到 Fake DNS 模块
4. Fake DNS 模块选择一个伪造的 IP 地址，比如 244.0.0.3，并把这个地址跟 www.google.com 关联起来
5. Fake DNS 根据 DNS 请求，生成相应的 DNS 答复，并把 244.0.0.3 当作 DNS 结果放进答复中，通过 tun2socks 把这个伪造的 DNS 答复返回给 app
6. app 得到 www.google.com 的 DNS 查询结果是 244.0.0.3
7. app 向 244.0.0.3 发出 HTTP 请求流量
8. HTTP 请求流量来到 tun2socks，tun2socks 向 Fake DNS 模块查询目的地址 244.0.0.3 是否是一个伪造的 IP 地址，如果是，向 Fake DNS 查询这个 IP 所关联的 域名，也即 www.google.com
9. tun2socks 现在已经得到 HTTP 请求流量的域名，把流量以及域名一并交给 V2Ray
10. V2Ray 有了域名，接下来路由什么的该怎么处理就怎么处理了
```

上面过程中，虽然 app 是发出了 DNS 请求流量，但这个流量被拦截下来了，并没有真正地发到互联网上；最终 V2Ray 也拿到了域名，如果这个域名匹配到代理规则，就会交到代理服务器来解析，也就是所谓的 远程 DNS 解析。

上面过程中，Fake DNS 模块如果没有对域名做过滤，对任何域名都返回伪造的 IP 地址，则可能会引起一些问题，有一种做法是在 Fake DNS 模块里内置一个域名列表，只对匹配到列表的域名返回 伪造 DNS 答复。

Fake DNS 不管是原理上还是实现上都是非常简单的，如果有兴趣可以看一下 [这里的实现代码](https://github.com/eycorsican/leaf/blob/master/leaf/src/app/fake_dns.rs)。

## DOH

在中国大陆可以使用阿里云 DNS 提供的 DoH 服务解析境内域名：`https://dns.alidns.com/dns-query`或 `https://223.5.5.5/dns-query` 。一般在远端配置：

```bash
{
 "dns": {
   "servers": [
     "https+local://1.1.1.1/dns-query",
     "localhost"
   ]
 }
}
```

DOH 服务商不像传统 DNS 那么成熟，目前网上提供 DOH 的服务商可以参考 **[curl - DNS over HTTPS](https://github.com/curl/curl/wiki/DNS-over-HTTPS)**

DOH 把 DNS 请求融入到常见的 https 流量当中，完全使用 DOH 可以避免出入口 ISP 知道你访问的域名。 但需要注意，只有在客户端、服务端都使用 DOH 协议（客户端使用 https 模式，服务端使用 https+local 模式）时候，VPS 出口上才不会出现传统的 UDP DNS 请求。